#ifndef __GMATH_H__
#define __GMATH_H__

#include <cmath>
#include <ostream>
#include <type_traits>

// 前置声明
template <typename T> struct Vec2;
template <typename T> struct Vec3;

/**
 * @brief 2D向量模板类
 * @tparam T 向量分量的类型，必须是算术类型
 */
template <typename T> struct Vec2 {
    static_assert(std::is_arithmetic<T>::value, "Vector type must be arithmetic");
    
    union {
        struct { T u, v; };
        struct { T x, y; };
        T raw[2];
    };

    // 构造函数
    constexpr Vec2() noexcept : u(0), v(0) {}
    constexpr Vec2(T _u, T _v) noexcept : u(_u), v(_v) {}

    // 运算符重载
    constexpr Vec2<T> operator+(const Vec2<T>& rhs) const noexcept {
        return Vec2<T>(u + rhs.u, v + rhs.v);
    }
    
    constexpr Vec2<T> operator-(const Vec2<T>& rhs) const noexcept {
        return Vec2<T>(u - rhs.u, v - rhs.v);
    }
    
    constexpr Vec2<T> operator*(T scalar) const noexcept {
        return Vec2<T>(u * scalar, v * scalar);
    }
    
    // 向量操作
    T norm() const { 
        return std::sqrt(x * x + y * y); 
    }
    
    Vec2<T>& normalize(T l = 1) {
        T n = norm();
        if (n > 0) {
            T scale = l / n;
            u *= scale;
            v *= scale;
        }
        return *this;
    }

    // 类型转换
    constexpr Vec3<T> toVec3() const noexcept { 
        return Vec3<T>(x, y, 1); 
    }

    // 友元声明
    template <typename U>
    friend std::ostream& operator<<(std::ostream& s, const Vec2<U>& v);
};

/**
 * @brief 3D向量模板类
 * @tparam T 向量分量的类型，必须是算术类型
 */
template <typename T> struct Vec3 {
    static_assert(std::is_arithmetic<T>::value, "Vector type must be arithmetic");
    
    union {
        struct { T x, y, z; };
        struct { T ivert, iuv, inorm; };
        T raw[3];
    };

    // 构造函数
    constexpr Vec3() noexcept : x(0), y(0), z(0) {}
    constexpr Vec3(T _x, T _y, T _z) noexcept : x(_x), y(_y), z(_z) {}

    // 运算符重载
    constexpr Vec3<T> operator^(const Vec3<T>& rhs) const noexcept {
        return Vec3<T>(y * rhs.z - z * rhs.y,
                      z * rhs.x - x * rhs.z,
                      x * rhs.y - y * rhs.x);
    }
    
    constexpr Vec3<T> operator+(const Vec3<T>& rhs) const noexcept {
        return Vec3<T>(x + rhs.x, y + rhs.y, z + rhs.z);
    }
    
    constexpr Vec3<T> operator-(const Vec3<T>& rhs) const noexcept {
        return Vec3<T>(x - rhs.x, y - rhs.y, z - rhs.z);
    }
    
    constexpr Vec3<T> operator*(T scalar) const noexcept {
        return Vec3<T>(x * scalar, y * scalar, z * scalar);
    }
    
    constexpr T operator*(const Vec3<T>& rhs) const noexcept {
        return x * rhs.x + y * rhs.y + z * rhs.z;
    }

    // 向量操作
    T norm() const { 
        return std::sqrt(x * x + y * y + z * z); 
    }
    
    Vec3<T>& normalize(T l = 1) {
        T n = norm();
        if (n > 0) {
            T scale = l / n;
            x *= scale;
            y *= scale;
            z *= scale;
        }
        return *this;
    }

    // 类型转换
    constexpr Vec2<T> toVec2() const noexcept { 
        return Vec2<T>(x, y); 
    }

    // 友元声明
    template <typename U>
    friend std::ostream& operator<<(std::ostream& s, const Vec3<U>& v);
};

// 类型别名
using Vec2f = Vec2<float>;
using Vec2i = Vec2<int>;
using Vec3f = Vec3<float>;
using Vec3i = Vec3<int>;

// 输出运算符实现
template <typename T>
std::ostream& operator<<(std::ostream& s, const Vec2<T>& v) {
    return s << "(" << v.x << ", " << v.y << ")";
}

template <typename T>
std::ostream& operator<<(std::ostream& s, const Vec3<T>& v) {
    return s << "(" << v.x << ", " << v.y << ", " << v.z << ")";
}

#endif // __GMATH_H__
